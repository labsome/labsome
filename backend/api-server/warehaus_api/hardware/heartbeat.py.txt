import os
import re
import sys
import json
from urllib2 import Request
from urllib2 import urlopen
from urlparse import urljoin
from commands import getstatusoutput
from traceback import format_exc
from collections import defaultdict

def run(cmdline, expected_status=0):
    status, output = getstatusoutput(cmdline)
    if status != expected_status:
        raise RuntimeError('Error while running {0!r}: {1}'.format(cmdline, output))
    return output

def collect_hw_net_info():
    net_info = defaultdict(dict)
    for iface in run('ip --oneline link').splitlines():
        mo = re.match(r'^\d:\s+(?P<iface_name>\w+):.*link/(?P<iface_type>\w+)\s+(?P<iface_addr>[\w:]+).*$', iface)
        if mo is not None:
            iface_info = mo.groupdict()
            if iface_info['iface_type'] == 'loopback':
                continue
            net_info[iface_info['iface_name']]['mac'] = iface_info['iface_addr']
    for iface in run('ip --oneline addr').splitlines():
        _, iface_name, iface_info = iface.split(' ', 2)
        if iface_name == 'lo':
            continue
        iface_info = iface_info.strip().split()
        if iface_info[0] == 'inet':
            net_info[iface_name].setdefault('inet', []).append(iface_info[1])
        if iface_info[0] == 'inet6':
            net_info[iface_name].setdefault('inet6', []).append(iface_info[1])
    return [dict(dev=dev, **fields) for dev, fields in net_info.iteritems()]

def collect_hw_pci_info():
    lspci = run('lspci -mm')
    pci_devices = []
    for line in lspci.splitlines():
        mo = re.match(r'^(?P<address>[:\w.]+)\s+"(?P<type>[^"]+)" "(?P<vendor>[^"]+)" "(?P<name>[^"]+)".*$', line)
        if mo is not None:
            pci_devices.append(mo.groupdict())
    return pci_devices

def collect_hw_disk_info():
    lsblk = run('lsblk --bytes --nodeps --pairs')
    disks = []
    for line in lsblk.splitlines():
        fields = {}
        for mo in re.finditer(r'(?P<key>[^=]+)="(?P<value>[^"]*)"', line):
            groupdict = mo.groupdict()
            key, value = groupdict['key'].strip().lower(), groupdict['value'].strip()
            try:
                value = int(value)
            except ValueError:
                pass
            fields[key] = value
        disks.append(fields)
    return disks

def collect_hw_cpu_info():
    cpus_info = open('/proc/cpuinfo').read()
    return [dict(map(lambda x: x.strip(), line.split(':', 1)) for line in cpu_info.splitlines() if line.strip()) for cpu_info in cpus_info.split('\n\n') if cpu_info.strip()]

MEM_KEYS = (
    'MemTotal',
    'MemFree',
    'MemAvailable',
    'SwapFree',
    'SwapFree',
    'SwapCached',
)

def collect_hw_mem_info():
    mem_info = {}
    for line in open('/proc/meminfo').read().splitlines():
        key, value = map(lambda x: x.strip(), line.split(':', 1))
        if key not in MEM_KEYS:
            continue
        try:
            value = int(value)
        except ValueError:
            if value.endswith('kB'):
                value = int(value[:-len('kB')]) * 1024
        mem_info[key] = value
    return mem_info

def collect_hw_fs_info():
    df = run('df --block-size=1 /')
    lines = df.splitlines()[1:]
    fields = df.splitlines()[1].split()
    return {'/': dict(
        dev             = fields[0],
        total_bytes     = int(fields[1]),
        used_bytes      = int(fields[2]),
        available_bytes = int(fields[3]),
    )}

info_collectors = dict(
    hw_net         = collect_hw_net_info,
    hw_pci_devices = collect_hw_pci_info,
    hw_disks       = collect_hw_disk_info,
    hw_cpu         = collect_hw_cpu_info,
    hw_mem         = collect_hw_mem_info,
    hw_fs          = collect_hw_fs_info,
)

def collect_info():
    info = dict(
        hostname = open('/proc/sys/kernel/hostname').read().strip(),
        info     = {},
        errors   = [],
    )
    for key, collect_func in info_collectors.iteritems():
        try:
            info['info'][key] = collect_func()
        except Exception as error:
            info['info'][key] = None
            info['errors'].append(dict(info=key, error=str(error), traceback=format_exc()))
    return info

def send(data):
    request = Request(WAREHAUS_HEARTBEAT_POST_URL, json.dumps(data), {'Content-Type': 'application/json'})
    response = urlopen(request).read()

info = collect_info()

# If WAREHAUS_HEARTBEAT_POST_URL is defined we're running from inside the agent
# so send the result back. If not just print the collected info for debugging
# since we're probably running from command-line.

if globals().get('WAREHAUS_HEARTBEAT_POST_URL'):
    send(info)
else:
    import pprint
    pprint.pprint(info)
